{
  "exemples": "Exemples:",
  "title": "Aide à la Recherche",
  "subtitle": "Syntaxe de requêtes Lucene et liste des champs d'index",
  "overview": "Aperçu",
  "overview.text": "Le «mini-langage» de la requête de recherche est utilisé par l'API de recherche. Les opérateurs vous permettent de personnaliser la recherche - les options disponibles sont expliquées ci-dessous:",
  "basic": "Recherche de base",
  "basic.text": "La requête de recherche est analysée en une série de termes et d'opérateurs. Un terme peut être un seul mot comme quick, brown ou une phrase, entouré de guillemets doubles \"quick brown\" qui recherche tous les mots de la phrase, dans le même ordre.",
  "basic.ex1": "\"quick brown fox\"",
  "basic.ex2": "quick OR brown OR fox",
  "fields": "Noms de champs",
  "fields.toc": "Champs",
  "fields.text": "En utilisant la recherche de base, seul le champ par défaut est recherché pour les termes de recherche, mais il est possible de spécifier d'autres champs dans la syntaxe de la requête:",
  "fields.ex1.title": "où le champ d'état contient active",
  "fields.ex1": "status:active",
  "fields.ex2.title": "où le champ de titre contient quick ou brown",
  "fields.ex2": "title:(quick OR brown)",
  "fields.ex3.title": "où le champ auteur contient la phrase exacte \"john smith\"",
  "fields.ex3": "author:\"John Smith\"",
  "fields.ex4.title": "où l'un des champs book.title, book.content ou book.date contient quick ou brown (notez comment nous devons échapper le * avec une barre oblique inverse):",
  "fields.ex4": "book.\\*:(quick OR brown)",
  "fields.ex5.title": "où le champ de titre a une valeur non nulle:",
  "fields.ex5": "_exists_:title",
  "fields.text2": "La banque de données Assemblyline est divisée en plusieurs index. Chaque index dispose des champs suivants disponibles pour les recherches. Les champs par défaut sont copiés dans le champ de recherche par défaut qui est utilisé dans le cas où vous n'utilisez que la recherche de base. Les champs stocké seront renvoyé par l'index lors de l'émission d'une requête.",
  "fields.important": "Important",
  "fields.important.text": "Lorsque vous utilisez le moteur de recherche dans l'interface utilisateur, votre requête de recherche est effectuée sur tous ces index en même temps, sauf si vous spécifiez explicitement l'index que vous souhaitez cibler.",
  "fields.idx_alert": "Champs d'index d'alerte:",
  "fields.idx_file": "Champs d'index de fichier:",
  "fields.idx_heuristic": "Champs d'index heuristique:",
  "fields.idx_result": "Champs d'index de résultat:",
  "fields.idx_signature": "Champs d'index de signature:",
  "fields.idx_submission": "Champs d'index de soumission:",
  "fields.idx_workflow": "Champs d'index de workflow:",
  "fields.idx_alert.toc": "Index d'alerte",
  "fields.idx_file.toc": "Index des fichiers",
  "fields.idx_heuristic.toc": "Index heuristique",
  "fields.idx_result.toc": "Index des résultats",
  "fields.idx_signature.toc": "Index de signature",
  "fields.idx_submission.toc": "Index de soumission",
  "fields.idx_workflow.toc": "Index de flux de travail",
  "fields.table.name": "Nom du champ",
  "fields.table.type": "Type",
  "fields.table.attrib": "Attributs",
  "fields.att.default": "défaut",
  "fields.att.list": "liste",
  "fields.att.stored": "stocké",
  "fields.att.default.tooltip": "Interrogé lorsqu'aucun champ n'est spécifié",
  "fields.att.list.tooltip": "Peut avoir plusieurs valeurs",
  "fields.att.stored.tooltip": "Renvoyé dans les résultats",
  "fuzziness": "Recherche approximative",
  "fuzziness.text": "Nous pouvons rechercher des termes similaires, mais pas exactement comme nos termes de recherche, en utilisant l'opérateur «d'approximation»:",
  "fuzziness.ex": "quikc~ brwn~ foks~",
  "fuzziness.text2": "Cela utilise la distance Damerau-Levenshtein pour trouver tous les termes avec un maximum de deux changements, où un changement est l'insertion, la suppression ou la substitution d'un seul caractère, ou la transposition de deux caractères adjacents.",
  "fuzziness.text3": "La distance d'édition par défaut est de 2, mais une distance d'édition de 1 devrait être suffisante pour attraper 80% de toutes les fautes d'orthographe humaines. Elle peut être spécifié comme:",
  "fuzziness.ex2": "quikc~1",
  "proximity": "Recherches de proximité",
  "proximity.text": "Alors qu'une requête de phrase (par exemple \"john smith\") attend tous les termes exactement dans le même ordre, une requête de proximité permet aux mots spécifiés d'être plus éloignés ou dans un ordre différent. De la même manière que les requêtes approximatives peuvent spécifier une distance d'édition maximale pour les caractères d'un mot, une recherche de proximité nous permet de spécifier une distance d'édition maximale des mots dans une phrase:",
  "proximity.ex": "\"quick fox\"~5",
  "proximity.text2": "Plus le texte d'un champ est proche de l'ordre d'origine spécifié dans la requête de recherche, plus ce document est considéré comme pertinent. Par rapport à l'exemple de requête ci-dessus, l'expression «quick fox» serait considérée comme plus pertinente que «quick brown fox».",
  "ranges": "Portées",
  "ranges.text": "Les portées peuvent être spécifiées pour les champs de date, numériques ou de chaîne. Les portées inclusives sont spécifiées avec des crochets [min TO max] et des portées exclusives avec des accolades {min TO max}.",
  "ranges.ex1.title": "Tous les jours en 2012:",
  "ranges.ex1": "date:[2012-01-01 TO 2012-12-31]",
  "ranges.ex2.title": "Tout cette année: (Utilisation de la syntaxe DateMath)",
  "ranges.ex2": "date:[now/y TO now/y+1y]",
  "ranges.ex3.title": "Tout depuis l'année de la date spécifique: (Utilisation de la syntaxe DateMath)",
  "ranges.ex3": "date:[2012-06-08||/y TO now]",
  "ranges.ex4.title": "Nombres 1..5",
  "ranges.ex4": "count:[1 TO 5]",
  "ranges.ex5.title": "Tags entre alpha et oméga, à l'exclusion de l'alpha et de l'oméga:",
  "ranges.ex5": "tag:{alpha TO omega}",
  "ranges.ex6.title": "Numéros à partir de 10",
  "ranges.ex6": "count:[10 TO *]",
  "ranges.ex7.title": "Dates antérieures à 2012",
  "ranges.ex7": "date:{* TO 2012-01-01}",
  "ranges.text2": "Les accolades et les crochets peuvent être combinés:",
  "ranges.ex8.title": "Numéros de 1 à 5, n'incluant pas 5",
  "ranges.ex8": "count:[1 TO 5}",
  "ranges.text3": "Les portées avec un côté illimité peuvent utiliser la syntaxe suivante:",
  "ranges.ex9": "age:>10\nage:>=10\nage:<10\nage:<=10",
  "ranges.text4": "Pour combiner une limite supérieure et inférieure avec la syntaxe simplifiée, vous devez joindre deux clauses avec un opérateur AND:",
  "ranges.ex10": "age:(>=10 AND <20)\nage:(+>=10 +<20)",
  "ranges.datemath": "Syntaxe de DateMath",
  "ranges.datemath.text": "L'expression commence par une date d'ancrage, qui peut être now, ou une date se terminant par ||. Cette date d'ancrage peut éventuellement être suivie d'une ou plusieurs expressions mathématiques:",
  "ranges.datemath.list1": "+ 1h: Ajouter une heure",
  "ranges.datemath.list2": "-1d: soustrait un jour",
  "ranges.datemath.list3": "/d: Arrondit au jour le plus proche",
  "ranges.datemath.text2": "Les unités de temps prises en charge diffèrent de celles prises en charge par les unités de temps pour les durées. Les unités prises en charge sont:",
  "ranges.datemath.ex1": "y => Années\nM => Mois\nw => Semaines\nd => Jours\nh => Heures\nH => Heures\nm => Minutes\ns => Secondes",
  "ranges.datemath.text3": "En supposant que le temps présent soit 2001-01-01 12:00:00, voici quelques exemples:",
  "ranges.datemath.ex2": "now+1h             =>  maintenant en millisecondes plus une heure. Devient: 2001-01-01 13:00:00\nnow-1h             =>  maintenant en millisecondes moins une heure. Devient: 2001-01-01 11:00:00\nnow-1h/d           =>  maintenant en millisecondes moins une heure, arrondi par jour. Devient: 2001-01-01 00:00:00\n2001.02.01||+1M/d  =>  2001-02-01 en millisecondes plus un mois arrondi par jour. Devient: 2001-03-01 00:00:00",
  "operator": "Opérateurs booléens",
  "operator.text": "Par défaut, tous les termes sont facultatifs, en autant qu'un terme correspond. Une recherche de foo bar baz trouvera tout document contenant un ou plusieurs des éléments foo, bar ou baz. Nous avons déjà discuté de l'operateur par défault ci-dessus qui vous permet de forcer tous les termes à être requis, mais il existe également des opérateurs booléens qui peuvent être utilisés dans la requête de recherche elle-même pour fournir plus de contrôle.",
  "operator.text2": "The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query:",
  "operator.ex1": "quick brown +fox -news",
  "operator.text3": "stipule que:",
  "operator.list1": "fox doit être présent",
  "operator.list2": "news doit être absent",
  "operator.list3": "quick and brown sont facultatifs - leur présence augmente la pertinence",
  "operator.text4": "Les opérateurs booléens familiers AND, OR et NOT (également écrits &&, || et!) Sont également pris en charge, mais sachez qu'ils ne respectent pas les règles de précédence habituelles, donc les parenthèses doivent être utilisées chaque fois que plusieurs opérateurs sont utilisés ensemble. Par exemple, la requête précédente pourrait être réécrite comme:",
  "operator.ex2": "((quick AND fox) OR (brown AND fox) OR fox) AND NOT news",
  "operator.text5": "Cette requête reproduit désormais correctement la logique de la requête d'origine, mais le score de pertinence ne ressemble guère à l'original.",
  "grouping": "Regroupement",
  "grouping.text": "Plusieurs termes ou clauses peuvent être regroupés avec des parenthèses, pour former des sous-requêtes:",
  "grouping.ex": "(quick OR brown) AND fox",
  "grouping.text2": "Les groupes peuvent également être utilisés pour cibler un champ particulier:",
  "grouping.ex2": "status:(active OR pending) title:(+full -\"text search\")",
  "reserved": "Caractères réservés",
  "reserved.text": "Si vous avez besoin d'utiliser l'un des caractères qui fonctionnent comme des opérateurs dans votre requête elle-même (et non comme des opérateurs), vous devez alors les échapper avec une barre oblique inverse.",
  "reserved.text2": "Par exemple, pour rechercher (1+1)=2, vous devez écrire votre requête sous la forme:",
  "reserved.ex": "\\(1\\+1\\)\\=2",
  "reserved.text3": "Les caractères réservés sont:",
  "reserved.ex2": "+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /",
  "reserved.text4": "Ne pas échapper correctement à ces caractères spéciaux peut entraîner une erreur de syntaxe qui empêche l'exécution de votre requête.",
  "reserved.note": "Noter",
  "reserved.text5": "< et > ne peuvent pas être échappés. Le seul moyen de les empêcher de tenter de créer une requête de plage est de les supprimer entièrement de la requête de recherche.",
  "toc": "Sommaire",
  "top": "Retour au début",
  "wildcard": "Caractères génériques",
  "wildcard.text": "Les recherches génériques peuvent être exécutées sur des termes individuels, en utilisant ? pour remplacer un seul caractère, et * pour remplacer zéro ou plusieurs caractères:",
  "wildcard.ex": "qu?ck bro*",
  "wildcard.text2": "Sachez que les requêtes génériques peuvent utiliser une énorme quantité de mémoire et sont lentes - pensez simplement au nombre de termes qui doivent être interrogés pour correspondre à la requête de recherche \"a * b * c *\".",
  "wildcard.note": "Noter",
  "wildcard.note.text": "Autoriser un caractère générique au début d'un mot (par exemple \"* ing\") est particulièrement lourd, car tous les termes de l'index doivent être examinés, juste au cas où ils correspondent.",
  "regex": "Expressions régulières",
  "regex.anchoring": "Ancrage",
  "regex.anchoring.text": "La plupart des moteurs d'expressions régulières vous permettent de faire correspondre n'importe quelle partie d'une chaîne. Si vous voulez que le modèle d'expression régulière commence au début de la chaîne ou se termine à la fin de la chaîne, vous devez l'ancrer spécifiquement, en utilisant ^ pour indiquer le début ou $ pour indiquer la fin.",
  "regex.anchoring.text2": "Les expressions régulières de Lucene sont toujours ancrées. Le modèle fourni doit correspondre à la chaîne entière. Pour la chaîne \"abcde\":",
  "regex.anchoring.ex": "ab.*     # correspondra\nabcd     # ne correspondra pas",
  "regex.chars": "Caractères autorisés",
  "regex.chars.text": "Tous les caractères Unicode peuvent être utilisés dans le modèle, mais certains caractères sont réservés et doivent être échappés. Les caractères réservés standard sont:",
  "regex.chars.ex": ". ? + * | { } [ ] ( ) \" \\",
  "regex.chars.text2": "Tout caractère réservé peut être échappé par une barre oblique inverse \"\\*\" comprenant une barre oblique inverse littérale: \"\\\\\"",
  "regex.chars.text3": "De plus, tous les caractères (à l'exception des guillemets doubles) sont interprétés littéralement lorsqu'ils sont entourés de guillemets doubles:",
  "regex.chars.ex2": "john\"@smith.com\"",
  "regex.any": "Correspondre à n'importe quel",
  "regex.any.text": "Le point \".\" Peut être utilisé pour représenter n'importe quel caractère. Pour la chaîne \"abcde\":",
  "regex.any.ex": "ab...   # correspondra\na.c.e   # correspondra",
  "regex.oneplus": "Un ou plus",
  "regex.oneplus.text": "Le signe plus \"+\" peut être utilisé pour répéter une ou plusieurs fois le motif le plus court précédent. Pour la chaîne \"aaabbb\":",
  "regex.oneplus.ex": "a+b+        # correspondra\naa+bb+      # correspondra\na+.+        # correspondra\naa+bbb+     # correspondra",
  "regex.zeroplus": "Zéro ou plus",
  "regex.zeroplus.text": "L'astérisque \"*\" peut être utilisé pour faire correspondre zéro ou plusieurs fois le modèle le plus court précédent. Pour la chaîne \"aaabbb\":",
  "regex.zeroplus.ex": "a*b*        # correspondra\na*b*c*      # correspondra\n.*bbb.*     # correspondra\naaa*bbb*    # correspondra",
  "regex.zeroone": "Zéro ou un",
  "regex.zeroone.text": "Le point d'interrogation \"?\" rend le modèle le plus court précédent facultatif. Il correspond à zéro ou une fois. Pour la chaîne \"aaabbb\":",
  "regex.zeroone.ex": "aaa?bbb?    # correspondra\naaaa?bbbb?  # correspondra\n.....?.?    # correspondra\naa?bb?      # ne correspondra pas",
  "regex.minmax": "Min à Max",
  "regex.minmax.text": "Les accolades \"{}\" peuvent être utilisées pour spécifier un nombre minimum et (facultatif) un nombre maximum de fois que le motif le plus court précédent peut se répéter. Les formes autorisés sont:",
  "regex.minmax.ex": "{5}     # répéter exactement 5 fois\n{2,5}   # répéter au moins deux fois et au plus 5 fois\n{2,}    # répéter au moins deux fois",
  "regex.minmax.text2": "Pour la chaîne \"aaabbb\":",
  "regex.minmax.ex2": "a{3}b{3}        # correspondra\na{2,4}b{2,4}    # correspondra\na{2,}b{2,}      # correspondra\n.{3}.{3}        # correspondra\na{4}b{4}        # ne correspondra pas\na{4,6}b{4,6}    # ne correspondra pas\na{4,}b{4,}      # ne correspondra pas",
  "regex.grouping": "Regroupement",
  "regex.grouping.text": "Les parenthèses \"()\" peuvent être utilisées pour former des sous-motifs. Les opérateurs de quantité énumérés ci-dessus fonctionnent sur le modèle précédent le plus court, qui peut être un groupe. Pour la chaîne \"ababab\":",
  "regex.grouping.ex": "(ab)+       # correspondra\nab(ab)+     # correspondra\n(..)+       # correspondra\n(...)+      # ne correspondra pas\n(ab)*       # correspondra\nabab(ab)?   # correspondra\nab(ab)?     # ne correspondra pas\n(ab){3}     # correspondra\n(ab){1,2}   # ne correspondra pas",
  "regex.alternation": "Alternance",
  "regex.alternation.text": "Le symbole de tube \"|\" agit comme un opérateur OR. Le match réussira si le motif du côté gauche ou du côté droit correspond. L'alternance s'applique au motif le plus long, pas au plus court. Pour la chaîne \"aabb\":",
  "regex.alternation.ex": "aabb|bbaa   # correspondra\naacc|bb     # ne correspondra pas\naa(cc|bb)   # correspondra\na+|b+       # ne correspondra pas\na+b+|b+a+   # correspondra\na+(b|c)+    # correspondra",
  "regex.class": "Classe de caractères",
  "regex.class.text": "Les plages de caractères potentiels peuvent être représentées sous forme de classes de caractères en les mettant entre crochets \"[]\". Un ^ en tête annule la classe de caractères. Les formes autorisés sont:",
  "regex.class.ex": "[abc]   # 'a' ou 'b' ou 'c'\n[a-c]   # 'a' ou 'b' ou 'c'\n[-abc]  # '-' ou 'a' ou 'b' ou 'c'\n[abc\\-] # '-' ou 'a' ou 'b' ou 'c'\n[^abc]  # tout caractère sauf 'a' ou 'b' ou 'c'\n[^a-c]  # tout caractère sauf 'a' ou 'b' ou 'c'\n[^-abc]  # tout caractère sauf '-' ou 'a' ou 'b' ou 'c'\n[^abc\\-] # tout caractère sauf '-' or 'a' ou 'b' ou 'c'",
  "regex.class.text2": "Notez que le tiret \"-\" indique une plage de caractères, sauf s'il s'agit du premier caractère ou s'il est échappé par une barre oblique inverse.",
  "regex.class.text3": "For la chaîne \"abcd\":",
  "regex.class.ex2": "ab[cd]+     # correspondra\n[a-d]+      # correspondra\n[^a-d]+     # ne correspondra pas",
  "regex.text": "Les modèles d'expression régulière peuvent être incorporés dans la requête de recherche en les encapsulant dans des barres obliques (\"/\"):",
  "regex.ex": "name:/joh?n(ath[oa]n)/",
  "regex.warning": "Avertissement",
  "regex.warning.text": "Avoir un caractère générique comme paramètre principal n'a aucun contrôle sur les expressions régulières. Une requête de recherche telle que la suivante forcerait la banque de données à visiter tous les termes de l'index, à utiliser avec précaution!:",
  "regex.warning.ex": "/.*n/",
  "regex.warning.follow": "La syntaxe d'expression régulière prise en charge est la suivante:"
}
