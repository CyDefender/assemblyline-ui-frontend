{
  "exemples": "Exemples:",
  "title": "Search help",
  "subtitle": "Lucene query syntax and index field list",
  "overview": "Overview",
  "overview.text": "The search query “mini-language” is used by the Search API. Operators allow you to customize the search -- the available options are explained bellow:",
  "basic": "Basic Search",
  "basic.text": "The search query is parsed into a series of terms and operators. A term can be a single word  like quick, brown or a phrase, surrounded by double quotes \"quick brown\" which searches for all the words in the phrase, in the same order.",
  "basic.ex1": "\"quick brown fox\"",
  "basic.ex2": "quick OR brown OR fox",
  "fields": "Field names",
  "fields.toc": "Fields",
  "fields.text": "By using basic search, only the default field is searched for the search terms, but it is possible to specify other fields in the query syntax:",
  "fields.ex1.title": "where the status field contains active",
  "fields.ex1": "status:active",
  "fields.ex2.title": "where the title field contains quick or brown",
  "fields.ex2": "title:(quick OR brown)",
  "fields.ex3.title": "where the author field contains the exact phrase \"john smith\"",
  "fields.ex3": "author:\"John Smith\"",
  "fields.ex4.title": "where any of the fields book.title, book.content or book.date contains quick or brown (note how we need to escape the * with a backslash):",
  "fields.ex4": "book.\\*:(quick OR brown)",
  "fields.ex5.title": "where the field title has any non-null value:",
  "fields.ex5": "_exists_:title",
  "fields.text2": "The Assemblyline datastore is divided in multiple indexes. Each index has the following fields available for searches. Default fields are copied over to the default search field that is used in the case where you only use basic search. Stored field will be returned by the index when issuing a query.",
  "fields.important": "Important",
  "fields.important.text": "When using the search engine in the UI, your search query is performed on all these indexes at the same time unless you explicitly specify which index you want to target.",
  "fields.idx_alert": "Alert index fields:",
  "fields.idx_file": "File index fields:",
  "fields.idx_heuristic": "Heuristic index fields:",
  "fields.idx_result": "Result index fields:",
  "fields.idx_signature": "Signature index fields:",
  "fields.idx_submission": "Submission index fields:",
  "fields.idx_workflow": "Workflow index fields:",
  "fields.idx_alert.toc": "Alert index",
  "fields.idx_file.toc": "File index",
  "fields.idx_heuristic.toc": "Heuristic index",
  "fields.idx_result.toc": "Result index",
  "fields.idx_signature.toc": "Signature index",
  "fields.idx_submission.toc": "Submission index",
  "fields.idx_workflow.toc": "Workflow index",
  "fields.table.name": "Field name",
  "fields.table.type": "Type",
  "fields.table.attrib": "Attributes",
  "fields.att.default": "default",
  "fields.att.list": "list",
  "fields.att.stored": "stored",
  "fields.att.default.tooltip": "Queried when no field specified",
  "fields.att.list.tooltip": "Can have multiple values",
  "fields.att.stored.tooltip": "Returned in results",
  "fuzziness": "Fuzziness",
  "fuzziness.text": "We can search for terms that are similar to, but not exactly like our search terms, using the “fuzzy” operator:\n",
  "fuzziness.ex": "quikc~ brwn~ foks~",
  "fuzziness.text2": "This uses the Damerau-Levenshtein distance to find all terms with a maximum of two changes, where a change is the insertion, deletion or substitution of a single character, or transposition of two adjacent characters.",
  "fuzziness.text3": "The default edit distance is 2, but an edit distance of 1 should be sufficient to catch 80% of all human misspellings. It can be specified as:",
  "fuzziness.ex2": "quikc~1",
  "proximity": "Proximity Searches",
  "proximity.text": "While a phrase query (eg \"john smith\") expects all of the terms in exactly the same order, a proximity query allows the specified words to be further apart or in a different order. In the same way that fuzzy queries can specify a maximum edit distance for characters in a word, a proximity search allows us to specify a maximum edit distance of words in a phrase:",
  "proximity.ex": "\"quick fox\"~5",
  "proximity.text2": "The closer the text in a field is to the original order specified in the search query, the more relevant that document is considered to be. When compared to the above example query, the phrase \"quick fox\" would be considered more relevant than \"quick brown fox\".",
  "ranges": "Ranges",
  "ranges.text": "Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets [min TO max] and exclusive ranges with curly brackets {min TO max}.",
  "ranges.ex1.title": "All days in 2012:",
  "ranges.ex1": "date:[2012-01-01 TO 2012-12-31]",
  "ranges.ex2.title": "Everything this year: (Using DateMath syntax)",
  "ranges.ex2": "date:[now/y TO now/y+1y]",
  "ranges.ex3.title": "Everything since the year of specific date: (Using DateMath syntax)",
  "ranges.ex3": "date:[2012-06-08||/y TO now]",
  "ranges.ex4.title": "Numbers 1..5",
  "ranges.ex4": "count:[1 TO 5]",
  "ranges.ex5.title": "Tags between alpha and omega, excluding alpha and omega:",
  "ranges.ex5": "tag:{alpha TO omega}",
  "ranges.ex6.title": "Numbers from 10 upwards",
  "ranges.ex6": "count:[10 TO *]",
  "ranges.ex7.title": "Dates before 2012",
  "ranges.ex7": "date:{* TO 2012-01-01}",
  "ranges.text2": "Curly and square brackets can be combined:",
  "ranges.ex8.title": "Numbers from 1 up to but not including 5",
  "ranges.ex8": "count:[1 TO 5}",
  "ranges.text3": "Ranges with one side unbounded can use the following syntax:",
  "ranges.ex9": "age:>10\nage:>=10\nage:<10\nage:<=10",
  "ranges.text4": "To combine an upper and lower bound with the simplified syntax, you would need to join two clauses with an AND operator:",
  "ranges.ex10": "age:(>=10 AND <20)\nage:(+>=10 +<20)",
  "ranges.datemath": "DateMath Syntax",
  "ranges.datemath.text": "The expression starts with an anchor date, which can either be now, or a date string ending with ||. This anchor date can optionally be followed by one or more maths expressions:",
  "ranges.datemath.list1": "+1h: Add one hour",
  "ranges.datemath.list2": "-1d: Subtracts one day",
  "ranges.datemath.list3": "/d: Rounds down to the nearest day",
  "ranges.datemath.text2": "The supported time units differ from those supported by time units for durations. The supported units are:",
  "ranges.datemath.ex1": "y    =>    Years\nM    =>    Months\nw    =>    Weeks\nd    =>    Days\nh    =>    Hours\nH    =>    Hours\nm    =>    Minutes\ns    =>    Seconds",
  "ranges.datemath.text3": "Assuming now is 2001-01-01 12:00:00, here are some examples:",
  "ranges.datemath.ex2": "now+1h             =>  now in milliseconds plus one hour. Resolves to: 2001-01-01 13:00:00\nnow-1h             =>  now in milliseconds minus one hour. Resolves to: 2001-01-01 11:00:00\nnow-1h/d           =>  now in milliseconds minus one hour, rounded by day. Resolves to: 2001-01-01 00:00:00\n2001.02.01||+1M/d  =>  2001-02-01 in milliseconds plus one month rounded by day. Resolves to: 2001-03-01 00:00:00",
  "operator": "Boolean Operators",
  "operator.text": "By default, all terms are optional, as long as one term matches. A search for foo bar baz will find any document that contains one or more of foo or bar or baz. We have already discussed the default_operator above which allows you to force all terms to be required, but there are also boolean operators which can be used in the search query itself to provide more control.",
  "operator.text2": "The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query:",
  "operator.ex1": "quick brown +fox -news",
  "operator.text3": "states that:",
  "operator.list1": "fox must be present",
  "operator.list2": "news must not be present",
  "operator.list3": "quick and brown are optional — their presence increases the relevance",
  "operator.text4": "The familiar boolean operators AND, OR and NOT (also written &&, || and !) are also supported but beware that they do not honor the usual precedence rules, so parentheses should be used whenever multiple operators are used together. For instance the previous query could be rewritten as:",
  "operator.ex2": "((quick AND fox) OR (brown AND fox) OR fox) AND NOT news",
  "operator.text5": "This form now replicates the logic from the original query correctly, but the relevance scoring bears little resemblance to the original.",
  "grouping": "Grouping",
  "grouping.text": "Multiple terms or clauses can be grouped together with parentheses, to form sub-queries:",
  "grouping.ex": "(quick OR brown) AND fox",
  "grouping.text2": "Groups can also be used to target a particular field:",
  "grouping.ex2": "status:(active OR pending) title:(+full -\"text search\")",
  "reserved": "Reserved Characters",
  "reserved.text": "If you need to use any of the characters which function as operator's in your query itself (and not as operators), then you should escape them with a leading backslash.",
  "reserved.text2": "For instance, to search for (1+1)=2, you would need to write your query as:",
  "reserved.ex": "\\(1\\+1\\)\\=2",
  "reserved.text3": "The reserved characters are:",
  "reserved.ex2": "+ - = && || > < ! ( ) { } [ ] ^ \" ~ * ? : \\ /",
  "reserved.text4": "Failing to escape these special characters correctly could lead to a syntax error which prevents your query from running.",
  "reserved.note": "Note",
  "reserved.text5": "< and > can’t be escaped at all. The only way to prevent them from attempting to create a range query is to remove them from the search query entirely.",
  "toc": "Contents",
  "top": "Back to top",
  "wildcard": "Wildcards",
  "wildcard.text": "Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters:",
  "wildcard.ex": "qu?ck bro*",
  "wildcard.text2": "Be aware that wildcard queries can use an enormous amount of memory and are very slow — just think how many terms need to be queried to match the search query \"a* b* c*\".",
  "wildcard.note": "Note",
  "wildcard.note.text": "Allowing a wildcard at the beginning of a word (eg \"*ing\") is particularly heavy, because all terms in the index need to be examined, just in case they match.",
  "regex": "Regular Expressions",
  "regex.anchoring": "Anchoring",
  "regex.anchoring.text": "Most regular expression engines allow you to match any part of a string. If you want the regexp pattern to start at the beginning of the string or finish at the end of the string, then you have to anchor it specifically, using ^ to indicate the beginning or $ to indicate the end.",
  "regex.anchoring.text2": "Lucene’s patterns are always anchored. The pattern provided must match the entire string. For string \"abcde\":",
  "regex.anchoring.ex": "ab.*     # match\nabcd     # no match",
  "regex.chars": "Allowed Characters",
  "regex.chars.text": "Any Unicode characters may be used in the pattern, but certain characters are reserved and must be escaped. The standard reserved characters are:",
  "regex.chars.ex": ". ? + * | { } [ ] ( ) \" \\",
  "regex.chars.text2": "Any reserved character can be escaped with a backslash \"\\*\" including a literal backslash character: \"\\\\\"",
  "regex.chars.text3": "Additionally, any characters (except double quotes) are interpreted literally when surrounded by double quotes:",
  "regex.chars.ex2": "john\"@smith.com\"",
  "regex.any": "Match Any",
  "regex.any.text": "The period \".\" can be used to represent any character. For string \"abcde\":",
  "regex.any.ex": "ab...   # match\na.c.e   # match",
  "regex.oneplus": "One or More",
  "regex.oneplus.text": "The plus sign \"+\" can be used to repeat the preceding shortest pattern once or more times. For string \"aaabbb\":",
  "regex.oneplus.ex": "a+b+        # match\naa+bb+      # match\na+.+        # match\naa+bbb+     # match",
  "regex.zeroplus": "Zero or More",
  "regex.zeroplus.text": "The asterisk \"*\" can be used to match the preceding shortest pattern zero-or-more times. For string \"aaabbb\":",
  "regex.zeroplus.ex": "a*b*        # match\na*b*c*      # match\n.*bbb.*     # match\naaa*bbb*    # match",
  "regex.zeroone": "Zero or One",
  "regex.zeroone.text": "The question mark \"?\" makes the preceding shortest pattern optional. It matches zero or one times. For string \"aaabbb\":",
  "regex.zeroone.ex": "aaa?bbb?    # match\naaaa?bbbb?  # match\n.....?.?    # match\naa?bb?      # no match",
  "regex.minmax": "Min to Max",
  "regex.minmax.text": "Curly brackets \"{}\" can be used to specify a minimum and (optionally) a maximum number of times the preceding shortest pattern can repeat. The allowed forms are:",
  "regex.minmax.ex": "{5}     # repeat exactly 5 times\n{2,5}   # repeat at least twice and at most 5 times\n{2,}    # repeat at least twice",
  "regex.minmax.text2": "For string \"aaabbb\":",
  "regex.minmax.ex2": "a{3}b{3}        # match\na{2,4}b{2,4}    # match\na{2,}b{2,}      # match\n.{3}.{3}        # match\na{4}b{4}        # no match\na{4,6}b{4,6}    # no match\na{4,}b{4,}      # no match",
  "regex.grouping": "Grouping",
  "regex.grouping.text": "Parentheses \"()\" can be used to form sub-patterns. The quantity operators listed above operate on the shortest previous pattern, which can be a group. For string \"ababab\":",
  "regex.grouping.ex": "(ab)+       # match\nab(ab)+     # match\n(..)+       # match\n(...)+      # no match\n(ab)*       # match\nabab(ab)?   # match\nab(ab)?     # no match\n(ab){3}     # match\n(ab){1,2}   # no match",
  "regex.alternation": "Alternation",
  "regex.alternation.text": "The pipe symbol \"|\" acts as an OR operator. The match will succeed if the pattern on either the left-hand side OR the right-hand side matches. The alternation applies to the longest pattern, not the shortest. For string \"aabb\":",
  "regex.alternation.ex": "aabb|bbaa   # match\naacc|bb     # no match\naa(cc|bb)   # match\na+|b+       # no match\na+b+|b+a+   # match\na+(b|c)+    # match",
  "regex.class": "Characters Class",
  "regex.class.text": "Ranges of potential characters may be represented as character classes by enclosing them in square brackets \"[]\". A leading ^ negates the character class. The allowed forms are:\n",
  "regex.class.ex": "[abc]   # 'a' or 'b' or 'c'\n[a-c]   # 'a' or 'b' or 'c'\n[-abc]  # '-' or 'a' or 'b' or 'c'\n[abc\\-] # '-' or 'a' or 'b' or 'c'\n[^abc]  # any character except 'a' or 'b' or 'c'\n[^a-c]  # any character except 'a' or 'b' or 'c'\n[^-abc]  # any character except '-' or 'a' or 'b' or 'c'\n[^abc\\-] # any character except '-' or 'a' or 'b' or 'c'",
  "regex.class.text2": "Note that the dash \"-\" indicates a range of characters, unless it is the first character or if it is escaped with a backslash.",
  "regex.class.text3": "For string \"abcd\":",
  "regex.class.ex2": "ab[cd]+     # match\n[a-d]+      # match\n[^a-d]+     # no match",
  "regex.text": "Regular expression patterns can be embedded in the search query by wrapping them in forward-slashes (\"/\"):",
  "regex.ex": "name:/joh?n(ath[oa]n)/",
  "regex.warning": "Warning",
  "regex.warning.text": "Having a wildcard as the leading parameter does not have any control over regular expressions. A search query such as the following would force the datastore to visit every term in the index, Use with caution!:",
  "regex.warning.ex": "/.*n/",
  "regex.warning.follow": "The supported regular expression syntax is the following:"
}
