{
  "exemples": "Exemples:",
  "title": "Search help",
  "subtitle": "Lucene query syntax and index field list",
  "overview": "Overview",
  "overview.text": "The query string “mini-language” is used by the Search API. Operators allow you to customize the search -- the available options are explained bellow:",
  "basic": "Basic Search",
  "basic.text": "The query string is parsed into a series of terms and operators. A term can be a single word  like quick, brown or a phrase, surrounded by double quotes \"quick brown\" which searches for all the words in the phrase, in the same order.",
  "basic.ex1": "\"quick brown fox\"",
  "basic.ex2": "quick OR brown OR fox",
  "fields": "Field names",
  "fields.toc": "Fields",
  "fields.text": "By using basic search, only the default field is searched for the search terms, but it is possible to specify other fields in the query syntax:",
  "fields.ex1.title": "where the status field contains active",
  "fields.ex1": "status:active",
  "fields.ex2.title": "where the title field contains quick or brown",
  "fields.ex2": "title:(quick OR brown)",
  "fields.ex3.title": "where the author field contains the exact phrase \"john smith\"",
  "fields.ex3": "author:\"John Smith\"",
  "fields.ex4.title": "where any of the fields book.title, book.content or book.date contains quick or brown (note how we need to escape the * with a backslash):",
  "fields.ex4": "book.\\*:(quick OR brown)",
  "fields.ex5.title": "where the field title has any non-null value:",
  "fields.ex5": "_exists_:title",
  "fields.text2": "The Assemblyline datastore is divided in multiple indexes. Each collection has the following field available for searches. Default fields are copied over to the default search field that is used in the case where you only use basic search. Stored field will be returned by the index when issuing a query.",
  "fields.important": "Important",
  "fields.important.text": "When using the search engine in the UI, your search query is performed on all these indexes at the same time unless you explicitely specify which index you want to target.",
  "fields.idx_alert": "Alert index fields:",
  "fields.idx_file": "File index fields:",
  "fields.idx_heuristic": "Heuristic index fields:",
  "fields.idx_result": "Result index fields:",
  "fields.idx_signature": "Signature index fields:",
  "fields.idx_submission": "Submission index fields:",
  "fields.idx_workflow": "Workflow index fields:",
  "fields.idx_alert.toc": "Alert index",
  "fields.idx_file.toc": "File index",
  "fields.idx_heuristic.toc": "Heuristic index",
  "fields.idx_result.toc": "Result index",
  "fields.idx_signature.toc": "Signature index",
  "fields.idx_submission.toc": "Submission index",
  "fields.idx_workflow.toc": "Workflow index",
  "fields.table.name": "Field name",
  "fields.table.type": "Type",
  "fields.table.attrib": "Attributes",
  "fields.att.default": "default",
  "fields.att.list": "list",
  "fields.att.stored": "stored",
  "fields.att.default.tooltip": "Queried when no field specified",
  "fields.att.list.tooltip": "Can have multiple values",
  "fields.att.stored.tooltip": "Returned in results",
  "fuzziness": "Fuzziness",
  "proximity": "Proximity Searches",
  "ranges": "Ranges",
  "ranges.datemath": "DateMath Syntax",
  "operator": "Boolean Operators",
  "grouping": "Grouping",
  "reserved": "Reserved Characters",
  "toc": "Contents",
  "top": "Back to top",
  "wildcard": "Wildcards",
  "wildcard.text": "Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters:",
  "wildcard.ex": "qu?ck bro*",
  "wildcard.text2": "Be aware that wildcard queries can use an enormous amount of memory and perform very badly — just think how many terms need to be queried to match the query string \"a* b* c*\".",
  "wildcard.note": "Note",
  "wildcard.note.text": "Allowing a wildcard at the beginning of a word (eg \"*ing\") is particularly heavy, because all terms in the index need to be examined, just in case they match.",
  "regex": "Regular Expressions",
  "regex.anchoring": "Anchoring",
  "regex.chars": "Allowed Characters",
  "regex.any": "Match Any",
  "regex.oneplus": "One or More",
  "regex.zeroplus": "Zero or More",
  "regex.zeroone": "Zero or One",
  "regex.minmax": "Min to Max",
  "regex.grouping": "Grouping",
  "regex.alternation": "Alternation",
  "regex.class": "Character Class",
  "regex.text": "Regular expression patterns can be embedded in the query string by wrapping them in forward-slashes (\"/\"):",
  "regex.ex": "name:/joh?n(ath[oa]n)/",
  "regex.warning": "Warning",
  "regex.warning.text": "Having a wildcard as the leading parameter does not have any control over regular expressions. A query string such as the following would force the datastore to visit every term in the index, Use with caution!:",
  "regex.warning.ex": "/.*n/",
  "regex.warning.follow": "The supported regular expression syntax is the following:"
}
